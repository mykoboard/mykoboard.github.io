const u=(s,e)=>({namespace:"lobby",type:s,payload:e}),l=(s,e)=>({namespace:"game",type:s,payload:e});function p(s){return s&&s.namespace==="lobby"}function y(s){return s&&s.namespace==="game"}class c{entries=[];constructor(e=[]){this.entries=e}static async calculateHash(e){const t=JSON.stringify({index:e.index,timestamp:e.timestamp,action:e.action,prevHash:e.prevHash,signerPublicKey:e.signerPublicKey}),a=new TextEncoder().encode(t),n=await crypto.subtle.digest("SHA-256",a);return Array.from(new Uint8Array(n)).map(h=>h.toString(16).padStart(2,"0")).join("")}async addEntry(e){const t=this.entries[this.entries.length-1],a=t?t.index+1:0,n=t?t.hash:"0",r=Date.now(),i={index:a,timestamp:r,action:e,prevHash:n},h=await c.calculateHash(i),o={...i,hash:h};return this.entries.push(o),o}getEntries(){return[...this.entries]}async verify(){for(let e=0;e<this.entries.length;e++){const t=this.entries[e],a=this.entries[e-1];if(e>0){if(t.prevHash!==a.hash)return!1}else if(t.prevHash!=="0")return!1;const{hash:n,...r}=t;if(await c.calculateHash(r)!==n)return!1}return!0}static fromEntries(e){return new c(e)}}export{c as Ledger,l as createGameMessage,u as createLobbyMessage,y as isGameMessage,p as isLobbyMessage};
